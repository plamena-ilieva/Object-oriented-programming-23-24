## Полиморфизъм
- едно име на функция, много различни имплементации
- Compile time полиморфизъм
- Run time полиморфизъм


## Статично и динамично свързване

- свързването (binding) е процесът, който се използва за преобразуване на идентификатори (например имена на променливи и функции) в адреси

### Статично свързване
- Статично свързване (Static binding/Early binding) - изборът на функцията, която трябва да се изпълни, става **по време на компилация** (Compile time)
- компилаторът (или линкерът) може директно да свърже името на идентификатора (например име на функция или променлива) с машинен адрес, с който да се замени извикването на функцията

```c++
#include <iostream>

class Base {
public: 
  void f() const  {
		std::cout << "Base::f()" << std::endl;
  }	
};

class Derived : public Base {
public:
  void f() const {
		std::cout << "Derived::f()" << std::endl;
  }	
};

void func(const Base& obj) {
    obj.f();
}	

int main() {
    Derived* der = new Derived();
	Base* base = bPtr;
	
	func(*base); // Base::f()
	func(*der); // Base::f()
}
```

### Динамично свързване
- Динамично свързване (Dynamic binding/Late binding) – изборът на функцията, която трябва да се изпълни, става **по време на изпълнение на програмата** (Run time)
- често се осъществява чрез указатели към функции (в контекста на ооп - виртуални)
- малко по-неефективно, тъй като включва допълнителни нива на пренасочване, но по-гъвкаво

```c++
#include <iostream>

class Base {
public: 
    virtual void f() const  {
		std::cout << "Base::f()" << std::endl;
    }	
};

class Derived : public Base {
public:
    void f() const override {
		std::cout << "Derived::f()" << std::endl;
    }	
};

void func(const Base& obj) {
    obj.f();
}	

int main() {
    Base* base = new Base();
    Derived* der = new Derived();
	
	func(*base); // Base::f()
	func(*der); // Derived::f()
}
```

## Виртуални функции
- виртуалните функции са член-функции, чието поведение може да бъде предефинирано в производните класове
- за разлика от невиртуалните функции, предефинираното поведение на функцията се запазва, дори ако няма информация по време на компилация за действителния тип на класа
- ако наследник се обработва с помощта на указател или референция към базовия клас, извикването на предефинираната виртуална функция ще извика поведението, дефинирано в наследника
- използват се главно за постигане на Runtime polymorphism

### Особености 
- не могат да бъдат статични
- ако една функция е декларирана като виртуална в базовия клас, то тя остава виртуална и в наследника, независимо дали се предефинира
- не е необходимо функцията в базовия клас да е достъпен или видим, за да бъде предефиниран (може да е private или наследен private)

- Ако функцията Derived::f предефинира функция Base::f, техните типове на връщане трябва да са еднакви или да са ковариантни, т.е.

    1. и двата типа са указатели или референции (lvalue или rvalue) към класове
    2. класът, към който се прави референция/указател в типа на връщане на Base::f(), трябва да бъде недвусмислен и достъпен пряк или косвен базов клас на класа, към който се прави референция/указател в типа на връщане на Derived::f()
    3. типът на връщане на Derived::f() трябва да еднакво или по-конкретен от типа на връщане на Base::f().

- Когато се прави извикване на виртуална функция, типът на върнатия указател се конвертира имплицитно към типа на връщане на базовата функция

### override
- override указва, че дадена функция презаписва функция от базовия клас
- ако в базовия клас няма такава функция, то кодът няма да се компилира.

### final
- final указва, че дадена функция не може да се презависва надолу по йерархията или че даден клас не може да се наследява